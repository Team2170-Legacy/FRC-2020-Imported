// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Subsystems/Vision.h"

Vision::Vision() {

    // add our own network table entries to limelight table
    auto table = nt::NetworkTableInstance::GetDefault().GetTable(limelightTableName);
    nt_distance = table->GetEntry("distance");
    nt_distance.SetDouble(0);
    nt_visionDrive = table->GetEntry("Vision Drive");
    nt_visionDrive.SetBoolean(false);
    nt_kP_Omega = table->GetEntry("Vision kP Omega");
    nt_kI_Omega = table->GetEntry("Vision kI Omega");
    nt_kP_Distance = table->GetEntry("Vision kP Distance");
    nt_angle_DB = table->GetEntry("Vision Angle Deadband");
    nt_kP_Omega.SetDouble(kP_Omega);
    nt_kI_Omega.SetDouble(kI_Omega);
    nt_kP_Distance.SetDouble(kP_Distance);
    nt_angle_DB.SetDouble(angleErrorDeadband);
    nt_competitionMode = table->GetEntry("Competition Mode Vision");
    nt_competitionMode.SetBoolean(competitionMode);

    // get driverstation preferences
    acceptableAlignmentError = frc::Preferences::GetInstance()->GetDouble(acceptableAlignmentErrorPrefName, acceptableAlignmentError);
    distanceSetpoint = frc::Preferences::GetInstance()->GetDouble(distanceSetpointPrefName, distanceSetpoint);
    takePeriodicSnapshots = frc::Preferences::GetInstance()->GetBoolean(takePeriodicSnapshotsPrefName, takePeriodicSnapshots);
    
    // open a datalogging file
    visionLogger.VisionLogger("/home/lvuser/VisionLogs/VisionLog_" + DataLogger::GetTimestamp() + ".csv");

    if (competitionMode) {
     // LEDs should start off by default
     limelight.SetCamMode(limelight.DriverCamera);
     limelight.SetLEDMode(limelight.forceOff);
    }
}

void Vision::Periodic() {
    competitionMode = nt_competitionMode.GetBoolean(competitionMode);
    bool targetLocked = limelight.TargetIsLocked();
    if (visionDriveActive) {  
        if (takePeriodicSnapshots) {
            loopsSinceLastImage++;
            if (loopsSinceLastImage >= loopsBetweenImages) {
                loopsSinceLastImage = 0;
                limelight.TakeSnapshot();
            }
        }
    }
    else if (targetLocked) {
        frc::SmartDashboard::PutNumber("LED Code",LEDCodes::VLock);
        distance = GetDistanceToPowerport();
        nt_distance.SetDouble(distance);
        distanceSetpoint = frc::Preferences::GetInstance()->GetDouble(distanceSetpointPrefName, distanceSetpoint);
        distanceError =  distanceSetpoint - distance;
        distanceError_DB = distanceError;
        angleError = limelight.GetHorizontalAngleToTarget();
        angleError_DB = angleError;
        speed = 0;
        omega = 0;    
    }
    else {
        distance = 0;
        distanceError = 0;
        distanceError_DB = 0;
        angleError = 0;
        angleError_DB = 0;
        speed = 0;
        omega = 0;        
    }
    if (competitionMode && !visionDriveActive) {
        limelight.SetCamMode(limelight.DriverCamera);
        limelight.SetLEDMode(limelight.forceOff);
    }
    else if (!competitionMode) {
       limelight.SetCamMode(limelight.VisionProcessor);
       limelight.SetLEDMode(limelight.currentPipelineMode);
    }
    visionLogger.WriteVisionData(targetLocked, visionDriveActive, distance,
                                 distanceError, distanceError_DB, angleError, angleError_DB, speed, omega);
}

/**
 * @brief Checks if the error to the target is less than a certain alignment threshold
 * 
 * @return true when error is less than alignment threshold and target is locked
 * @return false when error is greater than alignment threshold or target not locked
 */
bool Vision::IsAlignedWithTarget() {
    acceptableAlignmentError = frc::Preferences::GetInstance()->GetDouble(acceptableAlignmentErrorPrefName, acceptableAlignmentError);
    return abs(limelight.GetHorizontalAngleToTarget()) <= acceptableAlignmentError && limelight.TargetIsLocked();
}

/**
 * @brief Calculates distance from the front bumper of robot to the powerport in ft
 * Should only be called when a powerport target is locked
 *
 * @return distance from powerport 
 */
double Vision::GetDistanceToPowerport() {
    double camToPowerPortDistance = limelight.GetDistanceToTarget(cameraAngle, cameraHeight, powerportVisionTargetHeight);
    return camToPowerPortDistance - cameraDistanceFromFrontBumper;
}

/**
 * @brief prepares for vision drive
 */
void Vision::VisionDriveInit() {
    limelight.SetCamMode(limelight.VisionProcessor);
    limelight.SetLEDMode(limelight.currentPipelineMode);
    loopsSinceLastImage = loopsBetweenImages;
    visionDriveActive = true;
    nt_visionDrive.SetBoolean(true);
    omegaIntegrator = 0.0;
}

/**
 * @brief calcuates pair of speed (always 0) and omega to align with the locked target
 * 
 * @returns a pair of speed and omega to be passed to AutoVelocityArcadeDrive method in drivetrain
 */
std::pair<double, double> Vision::AlignWithLockedTarget() {   
    
    // reset omega and speed
    omega = 0.0;
    speed = 0.0;

    // fetch gains from network tables
    kP_Omega = nt_kP_Omega.GetDouble(kP_Omega);
    kI_Omega = nt_kI_Omega.GetDouble(kI_Omega);
    angleErrorDeadband = nt_angle_DB.GetDouble(angleErrorDeadband);

    // get angle error
    angleError = limelight.GetHorizontalAngleToTarget();
    angleError_DB = angleError;

    // deadband angle error
    if (angleError < angleErrorDeadband && angleError > -angleErrorDeadband)
    {
        angleError_DB = 0;
    }
    else if (angleError > angleErrorDeadband)
    {
        angleError_DB = angleError - angleErrorDeadband;
    }
    else
    {
        angleError_DB = angleError + angleErrorDeadband;
    }

    // omega PID calculations
    omegaIntegrator += angleError_DB * deltaTime;
    double omegaP = kP_Omega * angleError_DB;
    double omegaI = omegaIntegrator * kI_Omega;
    omega = omegaP + omegaI;

    // limit omega
    if (omega > omegaLimiter)
    {
        omega = omegaLimiter;
        omegaIntegrator -= angleError_DB * deltaTime; // PI anti-windup
    }
    else if (omega < -omegaLimiter)
    {
        omega = -omegaLimiter;
        omegaIntegrator -= angleError_DB * deltaTime; // PI anti-windup
    }

    return std::make_pair(speed, omega);
}

/**
 * @brief calcuates pair of speed and omega (always 0) to drive to the right distance from the powerport
 * Assumes the robot is already aligned with the powerport.
 * 
 * @returns a pair of speed and omega to be passed to AutoVelocityArcadeDrive method in drivetrain
 */
std::pair<double, double> Vision::DriveToDistanceSetpoint() {
    
    // reset speed and omega
    speed = 0;
    omega = 0;

    // fetch gains and preferences
    distanceSetpoint = frc::Preferences::GetInstance()->GetDouble(distanceSetpointPrefName, distanceSetpoint);
    kP_Distance = nt_kP_Distance.GetDouble(kP_Distance);

    // calculate distance error
    distance = GetDistanceToPowerport();
    distanceError = distanceSetpoint - distance;
    nt_distance.SetDouble(distance);

    // deadband distance error
    if (distanceError < distanceErrorDeadband && distanceError > -distanceErrorDeadband)
    {
        distanceError_DB = 0;
    }
    else if (angleError > angleErrorDeadband)
    {
        distanceError_DB = distanceError - distanceErrorDeadband;
    }
    else
    {
        distanceError_DB = distanceError + distanceErrorDeadband;
    }

    // speed PID calculations
    speed = kP_Distance * distanceError_DB;

    // limit speed
    if (speed > speedLimiter)
    {
        speed = speedLimiter;
    }
    else if (speed < -speedLimiter)
    {
        speed = -speedLimiter;
    }

    return std::make_pair(speed, omega);   
}

/**
 * @brief calcuates speed and omega to steer to face the target and be the correct distance away
 * 
 * @returns a pair of speed and omega to be passed to AutoVelocityArcadeDrive method in drivetrain
 */
std::pair<double, double> Vision::DriveToLockedTarget() {
    if (!IsAlignedWithTarget()) {
        return AlignWithLockedTarget();
    }
    else {
        return DriveToDistanceSetpoint();
    }
    return std::make_pair(0, 0);     
}

/**
 * @brief ends the vision drive
 */
void Vision::VisionDriveEnd() {
    if (competitionMode) {
    limelight.SetCamMode(limelight.DriverCamera);
    limelight.SetLEDMode(limelight.forceOff);
    }
    visionDriveActive = false;
    nt_visionDrive.SetBoolean(false);
}

/**
 * @brief starts or resumes vision data logging
 */
void Vision::EnableLogging() {
    visionLogger.StartSession();
}

/**
 * @brief ends or pauses vision data logging
 */
void Vision::DisableLogging() {
    visionLogger.EndSession();
}